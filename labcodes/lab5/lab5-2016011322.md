# Lab 5 实验报告

## 计64 陶东来 2016011322

### 练习 1

`load_icode`的前面大部分的工作是将elf格式的执行文件加载到内存中，为其配置vmm，建立用户栈、mm。需要补充的部分只有trapframe的初始化，初始化的方式参照注释即可。

#### 加载用户态应用程序的过程

在用户应用程序加载完毕之后，这个进程会进入调度器管辖范围。调度器被系统中断周期性唤醒，这时进入内核态开始进程调度。在调度器决定让这个进程占用CPU时，ucore会调用`proc_run`函数进行上下文切换工作，切换过程在LAB4的练习报告中已有要求，不再赘述。在切换完成之后，进程调度结束，回到用户态执行应用程序的代码。

### 练习 2

需要做到的是将父进程的用户内存页一一拷贝到子进程的用户内存空间中。

#### Copy-On-Write机制的实现

需要进行以下修改：

- 在`do_fork`时，子进程直接拷贝父进程的页目录表；在`dup_mmap`中，只保留拷贝vma链表的部分，弃用`copy_range`。
- 对于父进程的所有页增加引用计数1。取消父子进程页目录表的写权限，仅保存读权限。在`do_pgfault`中进行额外的处理，在这时才进行内存拷贝操作。

### 练习 3

#### fork

分配一个新的进程控制块，将父进程的内存空间复制到新进程。随后分配pid、设置关系信息等等。最后设置新进程为`RUNNABLE`，将其唤醒。

#### exec

在已经存在的上下文中导入新的可执行文件。会先检查当前进程用户态内存空间是否合法，然后释放虚拟内存空间，调用`load_icode`加载应用程序并重新设置当前进程的名字。

#### wait

遍历进程列表，找到指定的子进程。如果子进程的状态为`ZOMBIE`，则进行子进程的资源释放工作然后返回。如果不是`ZOMBIE`，则当前进程进入`SLEEPING`状态，调用`schedule`等待再次被唤醒。

#### exit

先释放页表项的物理内存，然后将自己的状态设为`ZOMBIE`并唤醒父进程，等待父进程完成扫尾工作。

#### 生命周期图
```
                                             +----------+
                                             + proc_run +
         alloc_proc           proc_inito     +          +
 (NULL) ------------> UNINIT -----------> RUNNABLE <----+
                                           ^ +
                                           + +
                                           + +  do_exit
                               wakeup_proc + +
                    SLEEPING <-------------+ +
                                do_sleep     +
                                             V
                        EXIT <----------- ZOMBIE
```
